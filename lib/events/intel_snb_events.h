/*
 * Copyright (c) 2010 Google, Inc
 * Contributed by Stephane Eranian <eranian@google.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
static const intel_x86_entry_t intel_snb_pe[]={
	{ .name = "AGU_BYPASS_CANCEL",
	  .desc = "Number of executed load operations with all the following traits: 1. addressing of the format [base + offset], 2. the offset is between 1 and 2047, 3. the address specified in the base register is in one page and the address [base+offset] is in another page",
	  .code = 0xb6,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "COUNT",
		  .udesc  = "This event counts executed load operations",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name = "ARITH",
	  .desc   = "Counts arithmetic multiply operations",
	  .code = 0x14,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "FPU_DIV_ACTIVE",
		  .udesc  = "Cycles that the divider is active, includes integer and floating point",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "FPU_DIV",
		  .udesc  = "Number of cycles the divider is activated, includes integer and floating point",
		  .ucode  = 0x1 | (1 << 10) | (1 << 16), /* edge=1 cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "FPU_DIV_ACTIVE:c=1:e=1",
		},
	  },
	  .numasks = 2
	},
	{ .name = "BR_INST_EXEC",
	  .desc   = "Branch instructions executed",
	  .code = 0x88,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "NONTAKEN_COND",
		  .udesc  = "All macro conditional non-taken branch instructions",
		  .ucode  = 0x41,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_COND",
		  .udesc  = "All macro conditional taken branch instructions",
		  .ucode  = 0x81,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_DIRECT_JUMP",
		  .udesc  = "All macro unconditional non-taken branch instructions, excluding calls and indirects",
		  .ucode  = 0x42,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_DIRECT_JUMP",
		  .udesc  = "All macro unconditional taken branch instructions, excluding calls and indirects",
		  .ucode  = 0x82,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_INDIRECT_JUMP_NON_CALL_RET",
		  .udesc  = "All non-taken indirect branches that are not calls nor returns",
		  .ucode  = 0x44,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_INDIRECT_JUMP_NON_CALL_RET",
		  .udesc  = "All taken indirect branches that are not calls nor returns",
		  .ucode  = 0x84,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_RETURN_NEAR",
		  .udesc  = "All non-taken indirect branches that have a return mnemonic",
		  .ucode  = 0x48,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_RETURN_NEAR",
		  .udesc  = "All taken indirect branches that have a return mnemonic",
		  .ucode  = 0x88,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_DIRECT_NEAR_CALL",
		  .udesc  = "All non-taken non-indirect calls",
		  .ucode  = 0x50,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_DIRECT_NEAR_CALL",
		  .udesc  = "All taken non-indirect calls",
		  .ucode  = 0x90,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_INDIRECT_NEAR_CALL",
		  .udesc  = "All non-taken indirect calls, including both register and memory indirect",
		  .ucode  = 0x60,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_INDIRECT_NEAR_CALL",
		  .udesc  = "All taken indirect calls, including both register and memory indirect",
		  .ucode  = 0xa0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_BRANCHES",
		  .udesc  = "All near executed branches instructions (not necessarily retired)",
		  .ucode  = 0xff,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname = "ANY_COND",
		  .udesc  = "All macro conditional branch instructions",
		  .ucode  = 0xc1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_DIRECT_JMP",
		  .udesc  = "All macro unconditional branch instructions, excluding calls and indirects",
		  .ucode  = 0xc2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_INDIRECT_JUMP_NON_CALL_RET",
		  .udesc  = "All indirect branches that are not calls nor returns",
		  .ucode  = 0xc4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_RETURN_NEAR",
		  .udesc  = "All indirect branches that have a return mnemonic",
		  .ucode  = 0xc8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_DIRECT_NEAR_CALL",
		  .udesc  = "All non-indirect calls",
		  .ucode  = 0xd0,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 18
	},
	{ .name = "BR_INST_RETIRED",
	  .desc   = "Retired branch instructions (Precise Event)",
	  .code = 0xc4,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "ALL_BRANCHES",
		  .udesc  = "All taken and not taken macro branches including far branches (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname = "CONDITIONAL",
		  .udesc  = "All taken and not taken macro conditional branch instructions (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "FAR_BRANCH",
		  .udesc  = "number of far branch instructions retired (Precise Event)",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "NEAR_CALL",
		  .udesc  = "All macro direct and indirect near calls, does not count far calls (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "NEAR_RETURN",
		  .udesc  = "number of near ret instructions retired (Precise Event)",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "NEAR_TAKEN",
		  .udesc  = "number of near branch taken instructions retired (Precise Event)",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "NOT_TAKEN",
		  .udesc  = "All not taken macro branch instructions retired (Precise Event)",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 7
	},
	{ .name = "BR_MISP_EXEC",
	  .desc   = "Mispredicted branches executed",
	  .code = 0x89,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "NONTAKEN_COND",
		  .udesc  = "All non-taken mispredicted macro conditional branch instructions",
		  .ucode  = 0x41,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_COND",
		  .udesc  = "All taken mispredicted macro conditional branch instructions",
		  .ucode  = 0x81,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_INDIRECT_JUMP_NON_CALL_RET",
		  .udesc  = "All non-taken mispredicted indirect branches that are not calls nor returns",
		  .ucode  = 0x44,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_INDIRECT_JUMP_NON_CALL_RET",
		  .udesc  = "All taken mispredicted indirect branches that are not calls nor returns",
		  .ucode  = 0x84,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_RETURN_NEAR",
		  .udesc  = "All non-taken mispredicted indirect branches that have a return mnemonic",
		  .ucode  = 0x48,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_RETURN_NEAR",
		  .udesc  = "All taken mispredicted indirect branches that have a return mnemonic",
		  .ucode  = 0x88,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_DIRECT_NEAR_CALL",
		  .udesc  = "All non-taken mispredicted non-indirect calls",
		  .ucode  = 0x50,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_DIRECT_NEAR_CALL",
		  .udesc  = "All taken mispredicted non-indirect calls",
		  .ucode  = 0x90,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NONTAKEN_INDIRECT_NEAR_CALL",
		  .udesc  = "All nontaken mispredicted indirect calls, including both register and memory indirect",
		  .ucode  = 0x60,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN_INDIRECT_NEAR_CALL",
		  .udesc  = "All taken mispredicted indirect calls, including both register and memory indirect",
		  .ucode  = 0xa0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_COND",
		  .udesc  = "All mispredicted macro conditional branch instructions",
		  .ucode  = 0xc1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_RETURN_NEAR",
		  .udesc  = "All mispredicted indirect branches that have a return mnemonic",
		  .ucode  = 0xc8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_DIRECT_NEAR_CALL",
		  .udesc  = "All mispredicted non-indirect calls",
		  .ucode  = 0xd0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_INDIRECT_JUMP_NON_CALL_RET",
		  .udesc  = "All mispredicted indirect branches that are not calls nor returns",
		  .ucode  = 0xc4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_BRANCHES",
		  .udesc  = "All mispredicted branch instructions",
		  .ucode  = 0xff,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},

	  },
	  .numasks = 15
	},
	{ .name = "BR_MISP_RETIRED",
	  .desc   = "Mispredicted retired branches (Precise Event)",
	  .code = 0xc5,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "ALL_BRANCHES",
		  .udesc  = "All mispredicted macro branches (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname = "CONDITIONAL",
		  .udesc  = "All mispredicted macro conditional branch instructions (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "NEAR_CALL",
		  .udesc  = "All macro direct and indirect near calls (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "NOT_TAKEN",
		  .udesc  = "Number of branch instructions retired that were mispredicted and not-taken (Precise Event)",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "TAKEN",
		  .udesc  = "Number of branch instructions retired that were mispredicted and taken (Precise Event)",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{.name = "BRANCH_INSTRUCTIONS_RETIRED", /* architected event */
		.code = 0x00c4,
		.cntmsk = 0xff,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "Count branch instructions at retirement. Specifically, this event counts the retirement of the last micro-op of a branch instruction",
		.equiv = "BR_INST_RETIRED:ALL_BRANCHES",
	},
	{.name = "MISPREDICTED_BRANCH_RETIRED", /* architected event */
	 .modmsk = INTEL_V3_ATTRS,
	 .cntmsk = 0xff,
	 .code= 0x00c5,
	 .desc =  "Count mispredicted branch instructions at retirement. Specifically, this event counts at retirement of the last micro-op of a branch instruction in the architectural path of the execution and experienced misprediction in the branch prediction hardware",
	 .equiv = "BR_MISP_RETIRED:ALL_BRANCHES",
	},
	{ .name = "LOCK_CYCLES",
	  .desc = "Locked cycles in L1D and L2",
	  .code = 0x63,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "SPLIT_LOCK_UC_LOCK_DURATION",
		  .udesc  = "Cycles in which the L1D and L2 are locked, due to a UC lock or split lock",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "CACHE_LOCK_DURATION",
		  .udesc  = "Cycles in which the L1D is locked",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "CPL_CYCLES",
	  .desc = "Unhalted core cycles at a specific ring level",
	  .code = 0x5c,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "RING0",
		  .udesc  = "Unhalted core cycles the thread was in ring 0",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RING0_TRANS",
		  .udesc  = "Transitions from rings 1, 2, or 3 to ring 0",
		  .ucode  = 0x1 | (1 << 10) | (1 << 16), /* edge=1 cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "RING0:c=1:e=1",
		},
		{ .uname = "RING123",
		  .udesc  = "Unhalted core cycles the thread was in rings 1, 2, or 3",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name = "CPU_CLK_UNHALTED",
	  .desc = "Cases when the core is unhalted at 100 Mhz",
	  .code = 0x3c,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "REF_P",
		  .udesc  = "Cycles when the core is unhalted (count at 100 Mhz)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "THREAD_P",
		  .udesc  = "Cycles when thread is not halted",
		  .ucode  = 0x00,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 2
	},
	{ .name = "DSB2MITE_SWITCHES",
	  .desc = "Number of DSB to MITE switches",
	  .code = 0xab,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "COUNT",
		  .udesc  = "Number of DSB to MITE switches",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname = "PENALTY_CYCLES",
		  .udesc  = "Cycles SB to MITE switches caused delay",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "DSB_FILL",
	  .desc = "DSB fills",
	  .code = 0xac,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ALL_CANCEL",
		  .udesc  = "Number of times a valid DSB fill has been cancelled for any reason",
		  .ucode  = 0xa,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "EXCEED_DSB_LINES",
		  .udesc  = "DSB Fill encountered > 3 DSB lines",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "OTHER_CANCEL",
		  .udesc  = "Number of times a valid DSB fill has been cancelled not because of exceeding way limit",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name = "DTLB_LOAD_MISSES",
	  .desc = "Data TLB load misses",
	  .code = 0x8,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "CAUSES_A_WALK",
		  .udesc  = "Miss in all TLB levels causes an page walk of any page size",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "STLB_HIT",
		  .udesc  = "Number of cache load STLB hits. No page walk",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "WALK_COMPLETED",
		  .udesc  = "Miss in all TLB levels causes a page walk that completes of any page size",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "WALK_DURATION",
		  .udesc  = "Cycles PMH is busy with a walk",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "DTLB_STORE_MISSES",
	  .desc   = "Data TLB store misses",
	  .code = 0x49,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "CAUSES_A_WALK",
		  .udesc  = "Miss in all TLB levels that causes a page walk of any page size (4K/2M/4M/1G)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "STLB_HIT",
		  .udesc  = "First level miss but second level hit; no page walk. Only relevant if multiple levels",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "WALK_COMPLETED",
		  .udesc  = "Miss in all TLB levels that causes a page walk that completes of any page size (4K/2M/4M/1G)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "WALK_DURATION",
		  .udesc  = "Cycles PMH is busy with this walk",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "FP_ASSIST",
	  .desc   = "X87 Floating point assists (Precise Event)",
	  .code = 0xca,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ANY",
		  .udesc  = "Cycles with any input/output SSE or FP assists",
		  .ucode  = 0x1e,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname = "SIMD_INPUT",
		  .udesc  = "Number of SIMD FP assists due to input values",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "SIMD_OUTPUT",
		  .udesc  = "Number of SIMD FP assists due to output values",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "X87_INPUT",
		  .udesc  = "Number of X87 assists due to input value",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "X87_OUTPUT",
		  .udesc  = "Number of X87 assists due to output value",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name = "HW_INTERRUPTS",
	  .desc = "Number of hardware interrupts received by the processor",
	  .code = 0xcb,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "RECEIVED",
		  .udesc  = "Number of hardware interrupts received by the processor",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "HW_PRE_REQ",
	  .desc = "Hardware prefetch requests",
	  .code = 0x4e,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "L1D_MISS",
		  .udesc  = "Hardware prefetch requests that misses the L1D cache. A request is counted each time it accesses the cache and misses it, including if a block is applicable or if it hits the full buffer, for example. This accounts for both L1 streamer and IP-based Hw prefetchers",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "ICACHE",
	  .desc = "Instruction Cache accesses",
	  .code = 0x80,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "MISSES",
		  .udesc  = "Number of Instruction Cache, Streaming Buffer and Victim Cache Misses. Includes UC accesses",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "IDQ",
	  .desc = "IDQ operations",
	  .code = 0x79,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "EMPTY",
		  .udesc  = "Cycles IDQ is empty",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MITE_UOPS",
		  .udesc  = "Number of uops delivered to IDQ from MITE path",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DSB_UOPS",
		  .udesc  = "Number of uops delivered to IDQ from DSB path",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MS_DSB_UOPS",
		  .udesc  = "Number of uops delivered to IDQ when MS busy by DSB",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MS_MITE_UOPS",
		  .udesc  = "Number of uops delivered to IDQ when MS busy by MITE",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MS_UOPS",
		  .udesc  = "Number of uops were delivered to IDQ from MS by either DSB or MITE",
		  .ucode  = 0x30,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MITE_UOPS_CYCLES",
		  .udesc  = "Cycles where uops are delivered to IDQ from MITE (MITE active)",
		  .ucode  = 0x4 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "MITE_UOPS:c=1",
		},
		{ .uname = "DSB_UOPS_CYCLES",
		  .udesc  = "Cycles where uops are delivered to IDQ from DSB (DSB active)",
		  .ucode  = 0x8 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .modhw  = _INTEL_X86_ATTR_C,
		},
		{ .uname = "MS_DSB_UOPS_CYCLES",
		  .udesc  = "Cycles where uops delivered to IDQ when MS busy by DSB",
		  .ucode  = 0x10 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "MS_DSB_UOPS:c=1",
		},
		{ .uname = "MS_MITE_UOPS_CYCLES",
		  .udesc  = "Cycles where uops delivered to IDQ when MS busy by MITE",
		  .ucode  = 0x20 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "MS_MITE_UOPS:c=1",
		},
		{ .uname = "MS_UOPS_CYCLES",
		  .udesc  = "Cycles where uops delivered to IDQ from MS by either BSD or MITE",
		  .ucode  = 0x30 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "MS_UOPS:c=1",
		},
		{ .uname = "ALL_DSB_UOPS",
		  .udesc  = "Number of uops deliver from either DSB paths",
		  .ucode  = 0x18,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_DSB_CYCLES",
		  .udesc  = "Cycles MITE/MS deliver anything",
		  .ucode  = 0x18 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .modhw  = _INTEL_X86_ATTR_C,
		},
		{ .uname = "ALL_MITE_UOPS",
		  .udesc  = "Number of uops delivered from either MITE paths",
		  .ucode  = 0x24,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_MITE_CYCLES",
		  .udesc  = "Cycles DSB/MS deliver anything",
		  .ucode  = 0x24 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .modhw  = _INTEL_X86_ATTR_C,
		},
		{ .uname = "ANY_UOPS",
		  .udesc  = "Number of uops delivered to IDQ from any path",
		  .ucode  = 0x3c,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MS_DSB_UOPS_OCCUR",
		  .udesc  = "Occurences of DSB MS going active",
		  .ucode  = 0x10 | (1 << 10) | (1 << 16), /* edge=1 cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "MS_DSB_UOPS:c=1:e=1",
		},
	  },
	  .numasks = 17
	},
	{ .name = "IDQ_UOPS_NOT_DELIVERED",
	  .desc = "Uops not delivered",
	  .code = 0x9c,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "CORE",
		  .udesc  = "Number of non-delivered uops to RAT (use cmask to qualify further)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "ILD_STALL",
	  .desc   = "Instruction Length Decoder stalls",
	  .code = 0x87,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "LCP",
		  .udesc  = "Stall caused by changing prefix length of the instruction",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "IQ_FULL",
		  .udesc  = "Stall cycles due to IQ full",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "INSTS_WRITTEN_TO_IQ",
	  .desc = "Instructions written to IQ",
	  .code = 0x17,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "INSTS",
		  .udesc  = "Number of instructions written to IQ every cycle",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "INST_RETIRED",
	  .desc   = "Instructions retired",
	  .code = 0xc0,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "ANY_P",
		  .udesc  = "Number of instructions retired",
		  .ucode  = 0x0,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname  = "PREC_DIST",
		  .udesc  = "Precise instruction retired event to reduce effect of PEBS shadow IP distribution (Precise Event)",
		  .ucntmsk= 0x2, /* only on PMC1 */
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},

	  },
	  .numasks = 2
	},
	{.name = "INSTRUCTION_RETIRED",
		.code = 0x00c0,
		.cntmsk = 0x10000000full,
		.modmsk = INTEL_FIXED3_ATTRS,
		.desc =  "Number of instructions at retirement",
	},
	{.name = "INSTRUCTIONS_RETIRED",
		.code = 0x00c0,
		.cntmsk = 0x10000000full,
		.modmsk = INTEL_FIXED3_ATTRS,
		.desc =  "This is an alias for INSTRUCTION_RETIRED",
		.equiv = "INSTRUCTION_RETIRED",
	},
	{ .name = "INT_MISC",
	  .desc = "Miscellaneous internals",
	  .code = 0xd,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "RAT_STALL_CYCLES",
		  .udesc  = "Cycles RAT external stall is sent to IDQ for this thread",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RECOVERY_CYCLES",
		  .udesc  = "Cycles waiting to be recovered after Machine Clears due to all other cases except JEClear",
		  .ucode  = 0x3 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .modhw  = _INTEL_X86_ATTR_C,
		},
		{ .uname = "RECOVERY_STALLS_COUNT",
		  .udesc  = "Number of times need to wait after Machine Clears due to all other cases except JEClear",
		  .ucode  = 0x3 | (1 << 10) | (1 << 16), /* edge=1 cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .modhw  = _INTEL_X86_ATTR_E | _INTEL_X86_ATTR_C,
		},
	  },
	  .numasks = 3
	},
	{ .name = "ITLB",
	  .desc = "Instruction TLB",
	  .code = 0xae,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "FLUSH",
		  .udesc  = "Number of ITLB flushes, includes 4k/2M/4M pages",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "ITLB_MISSES",
	  .desc = "Instruction TLB misses",
	  .code = 0x85,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "CAUSES_A_WALK",
		  .udesc  = "Miss in all TLB levels that causes a page walk",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "STLB_HIT",
		  .udesc  = "Number of cache load STLB hits; no page walk",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "WALK_COMPLETED",
		  .udesc  = "Miss in all TLB levels that causes a completed page walk",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "WALK_DURATION",
		  .udesc  = "Cycles PMH is busy with this walk",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "L1D",
	  .desc = "L1D cache",
	  .code = 0x51,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ALLOCATED_IN_M",
		  .udesc  = "Number of allocations of L1D cache lines in modified (M) state",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_M_REPLACEMENT",
		  .udesc  = "Number of cache lines in M-state evicted of L1D due to snoop HITM or dirty line replacement",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "M_EVICT",
		  .udesc  = "Number of modified lines evicted from L1D due to replacement",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "REPLACEMENT",
		  .udesc  = "Number of cache lines brought into the L1D cache",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "L1D_BLOCKS",
	  .desc = "L1D is blocking",
	  .code = 0xbf,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "BANK_CONFLICT",
		  .udesc  = "Number of dispatched loads cancelled due to L1D bank conflicts with other load ports",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "BANK_CONFLICT_CYCLES",
		  .udesc  = "Cycles with l1d blocks due to bank conflicts",
		  .ucode  = 0x5,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 2
	},
	{ .name = "L1D_PEND_MISS",
	  .desc = "L1D pending misses",
	  .code = 0x48,
	  .cntmsk = 0x4,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "EDGE",
		  .udesc  = "Occurrences of L1D_PEND_MISS going active",
		  .ucode  = 0x1 | (1 << 10) | (1 << 16), /* edge=1 cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "PENDING:e=1:c=1",
		},
		{ .uname = "PENDING",
		  .udesc  = "Number of L1D load misses outstanding every cycle",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PENDING_CYCLES",
		  .udesc  = "Cycles with L1D load misses outstanding",
		  .ucode  = 0x1 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "PENDING:c=1",
		},
	  },
	  .numasks = 3
	},
	{ .name = "L2_L1D_WB_RQSTS",
	  .desc = "Writeback requests from L1D to L2",
	  .code = 0x28,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "HIT_E",
		  .udesc  = "Non rejected writebacks from L1D to L2 cache lines in E state",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "HIT_M",
		  .udesc  = "Non rejected writebacks from L1D to L2 cache lines in M state",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "L2_LINES_IN",
	  .desc   = "L2 lines alloacated",
	  .code = 0xf1,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ANY",
		  .udesc  = "L2 cache lines filling (counting does not cover rejects)",
		  .ucode  = 0x7,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "E",
		  .udesc  = "L2 cache lines in E state (counting does not cover rejects)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "I",
		  .udesc  = "L2 cache lines in I state (counting does not cover rejects)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "S",
		  .udesc  = "L2 cache lines in S state (counting does not cover rejects)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "L2_LINES_OUT",
	  .desc   = "L2 lines evicted",
	  .code = 0xf2,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "DEMAND_CLEAN",
		  .udesc  = "L2 clean line evicted by a demand",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_DIRTY",
		  .udesc  = "L2 dirty line evicted by a demand",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PREFETCH_CLEAN",
		  .udesc  = "L2 clean line evicted by a prefetch",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PREFETCH_DIRTY",
		  .udesc  = "L2 dirty line evicted by an MLC Prefetch",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DIRTY_ANY",
		  .udesc  = "Any L2 dirty line evicted (does not cover rejects)",
		  .ucode  = 0xa,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name = "L2_RQSTS",
	  .desc   = "L2 requests",
	  .code = 0x24,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ALL_CODE_RD",
		  .udesc  = "Any ifetch request to L2 cache",
		  .ucode  = 0x30,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "CODE_RD_HIT",
		  .udesc  = "L2 cache hits when fetching instructions",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "CODE_RD_MISS",
		  .udesc  = "L2 cache misses when fetching instructions",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_DEMAND_DATA_RD",
		  .udesc  = "Demand  data read requests to L2 cache",
		  .ucode  = 0x3,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_DEMAND_RD_HIT",
		  .udesc  = "Demand data read requests that hit L2",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_PF",
		  .udesc  = "Any L2 HW prefetch request to L2 cache",
		  .ucode  = 0xc0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PF_HIT",
		  .udesc  = "Requests from the L2 hardware prefetchers that hit L2 cache",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PF_MISS",
		  .udesc  = "Requests from the L2 hardware prefetchers that miss L2 cache",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RFO_ANY",
		  .udesc  = "Any RFO requests to L2 cache",
		  .ucode  = 0xc,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RFO_HITS",
		  .udesc  = "RFO requests that hit L2 cache",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RFO_MISS",
		  .udesc  = "RFO requests that miss L2 cache",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 11
	},
	{ .name = "L2_STORE_LOCK_RQSTS",
	  .desc = "L2 store lock requests",
	  .code = 0x27,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "HIT_E",
		  .udesc  = "RFOs that hit cache lines in E state",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MISS",
		  .udesc  = "RFOs that miss cache (I state)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "HIT_M",
		  .udesc  = "RFOs that hit cache lines in M state",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL",
		  .udesc  = "RFOs that access cache lines in any state",
		  .ucode  = 0xf,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 4
	},
	{ .name = "L2_TRANS",
	  .desc   = "L2 transactions",
	  .code = 0xf0,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ALL",
		  .udesc  = "Transactions accessing MLC pipe",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "CODE_RD",
		  .udesc  = "L2 cache accesses when fetching instructions",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "L1D_WB",
		  .udesc  = "L1D writebacks that access L2 cache",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "LOAD",
		  .udesc  = "Demand Data Read* requests that access L2 cache",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "L2_FILL",
		  .udesc  = "L2 fill requests that access L2 cache",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "L2_WB",
		  .udesc  = "L2 writebacks that access L2 cache",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_PREFETCH",
		  .udesc  = "L2 or L3 HW prefetches that access L2 cache (including rejects)",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RFO",
		  .udesc  = "RFO requests that access L2 cache",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 8
	},
	{.name = "LAST_LEVEL_CACHE_MISSES", /* architected event */
		.code = 0x412e,
		.cntmsk = 0xff,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "This is an alias for LLC_MISSES",
		.equiv = "L3_LAT_CACHE:MISS"
	},
	{.name = "LLC_MISSES",
		.code = 0x412e,
		.cntmsk = 0xff,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "Alias for LAST_LEVEL_CACHE_MISSES",
		.equiv = "LAST_LEVEL_CACHE_MISSES"
	},

	{.name = "LAST_LEVEL_CACHE_REFERENCES", /* architected event */
		.code = 0x4f2e,
		.cntmsk = 0xff,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "This is an alias for LLC_REFERENCES",
		.equiv = "L3_LAT_CACHE:REFERENCE"
	},
	{.name = "LLC_REFERENCES",
		.code = 0x4f2e,
		.cntmsk = 0xff,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "Alias for LAST_LEVEL_CACHE_REFERENCES",
		.equiv = "LAST_LEVEL_CACHE_REFERENCES",
	},

	{ .name = "LD_BLOCKS",
	  .desc = "Blocking loads",
	  .code = 0x3,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "DATA_UNKNOWN",
		  .udesc  = "Blocked loads due to store buffer blocks with unknown data",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "STORE_FORWARD",
		  .udesc  = "Loads blocked by overlapping with store buffer that cannot be forwarded",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "NO_SR",
		  .udesc  = "Number of split loads blocked due to resource not available",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_BLOCK",
		  .udesc  = "Number of cases where any load is blocked but has not DCU miss",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},

	  },
	  .numasks = 4
	},
	{ .name = "LD_BLOCKS_PARTIAL",
	  .desc = "Partial load blocks",
	  .code = 0x7,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ADDRESS_ALIAS",
		  .udesc  = "False dependencies in MOB due to partial compare on address",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ALL_STA_BLOCK",
		  .udesc  = "Number of times that load operations are temporarily blocked because of older stores, with addresses that are not yet known. A load operation may incur more than one block of this type",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},

	  },
	  .numasks = 2
	},
	{ .name = "LOAD_HIT_PRE",
	  .desc = "Load dispatches that hit fill buffer",
	  .code = 0x4c,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "HW_PF",
		  .udesc  = "Non sw-prefetch load dispatches that hit the fill buffer allocated for HW prefetch",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "SW_PF",
		  .udesc  = "Non sw-prefetch load dispatches that hit the fill buffer allocated for SW prefetch",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "L3_LAT_CACHE",
	  .desc = "Core-originated cacheable demand requests to L3",
	  .code = 0x2e,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "MISS",
		  .udesc  = "Core-originated cacheable demand requests missed L3",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "REFERENCE",
		  .udesc  = "Core-originated cacheable demand requests that refer to L3",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "MACHINE_CLEARS",
	  .desc   = "Machine clear asserted",
	  .code = 0xc3,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "MASKMOV",
		  .udesc  = "The number of executed Intel AVX masked load operations that refer to an illegal address range with the mask bits set to 0",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MEMORY_ORDERING",
		  .udesc  = "Number of Memory Ordering Machine Clears detected",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "SMC",
		  .udesc  = "Self-Modifying Code detected",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name = "MEM_LOAD_LLC_HIT_RETIRED",
	  .desc = "L3 hit loads retired (Precise Event)",
	  .code = 0xd2,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "XSNP_HIT",
		  .udesc  = "Load LLC Hit and a cross-core Snoop hits in on-pkg core cache (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "XSNP_HITM",
		  .udesc  = "Load had HitM Response from a core on same socket (shared LLC) (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "XSNP_MISS",
		  .udesc  = "Load LLC Hit and a cross-core Snoop missed in on-pkg core cache (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "XSNP_NONE",
		  .udesc  = "Load hit in last-level (L3) cache with no snoop needed (Precise Event)",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "MEM_LOAD_MISC_RETIRED",
	  .desc = "Loads and some non simd split loads retired",
	  .code = 0xd4,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "LLC_MISS",
		  .udesc  = "Counts load driven L3 misses and some non simd split loads (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "MEM_LOAD_RETIRED",
	  .desc   = "Memory loads retired",
	  .code = 0xd1,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "HIT_LFB",
		  .udesc  = "A load missed L1D but hit the Fill Buffer (Precise Event)",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO | INTEL_X86_PEBS,
		},
		{ .uname = "L1_HIT",
		  .udesc  = "Load hit in nearest-level (L1D) cache (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO | INTEL_X86_PEBS,
		},
		{ .uname = "L2_HIT",
		  .udesc  = "Load hit in mid-level (L2) cache (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO | INTEL_X86_PEBS,
		},
		{ .uname = "L3_HIT",
		  .udesc  = "Load hit in last-level (L3) cache with no snoop needed (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "MEM_TRANS_RETIRED",
	  .desc = "Memory transactions retired (Precise Event)",
	  .code = 0xcd,
	  .cntmsk = 0x8, /* only on PMC3 */
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "LATENCY_ABOVE_THRESHOLD",
		  .udesc  = "Memory load instructions retired above programmed clocks, minimum value threshold is 4 (Precise Event required)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "PRECISE_STORE",
		  .udesc  = "capture where stores occur, must use with PEBS (Precise Event required)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "MEM_UOP_RETIRED",
	  .desc = "Memory uops retired (Precise Event)",
	  .code = 0xd0,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "ANY_LOADS",
		  .udesc  = "Any retired loads (Precise Event)",
		  .ucode  = 0x81,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_STORES",
		  .udesc  = "Any retired stores (Precise Event)",
		  .ucode  = 0x82,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "LOCK_LOADS",
		  .udesc  = "Locked retired loads (Precise Event)",
		  .ucode  = 0x21,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "LOCK_STORES",
		  .udesc  = "Locked retired stores (Precise Event)",
		  .ucode  = 0x22,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "SPLIT_LOADS",
		  .udesc  = "Retired loads causing cacheline splits (Precise Event)",
		  .ucode  = 0x41,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "SPLIT_STORES",
		  .udesc  = "Retired stores causing cacheline splits (Precise Event)",
		  .ucode  = 0x42,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "STLB_MISS_LOADS",
		  .udesc  = "STLB misses dues to retired loads (Precise Event)",
		  .ucode  = 0x11,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "STLB_MISS_STORES",
		  .udesc  = "STLB misses dues to retired stores (Precise Event)",
		  .ucode  = 0x12,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 8
	},
	{ .name = "MISALIGN_MEM_REF",
	  .desc = "Misaligned memory references",
	  .code = 0x5,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "LOADS",
		  .udesc  = "Speculative cache-line split load uops dispatched to the L1D",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "STORES",
		  .udesc  = "Speculative cache-line split Store-address uops dispatched to L1D",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name = "OFFCORE_REQUESTS",
	  .desc   = "Offcore requests",
	  .code = 0xb0,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ALL_DATA_READ",
		  .udesc  = "Demand and prefetch read requests sent to uncore",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_CODE_RD",
		  .udesc  = "Offcore code read requests, including cacheable and un-cacheables",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_DATA_RD",
		  .udesc  = "Demand Data Read requests sent to uncore",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_RFO",
		  .udesc  = "Offcore Demand RFOs, includes regular RFO, Locks, ItoM",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "OFFCORE_REQUESTS_BUFFER",
	  .desc   = "Offcore requests buffer",
	  .code = 0xb2,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "SQ_FULL",
		  .udesc  = "Offcore requests buffer cannot take more entries for this thread core",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "OFFCORE_REQUESTS_OUTSTANDING",
	  .desc   = "Outstanding offcore requests",
	  .code = 0x60,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ALL_DATA_RD_CYCLES",
		  .udesc  = "Cycles with cacheable data read transactions in the superQ",
		  .ucode  = 0x8 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "ALL_DATA_RD:c=1",
		},
		{ .uname = "DEMAND_CODE_RD_CYCLES",
		  .udesc  = "Cycles with demand code reads transactions in the superQ",
		  .ucode  = 0x2 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "DEMAND_CODE_RD:c=1",
		},
		{ .uname = "DEMAND_DATA_RD_CYCLES",
		  .udesc  = "Cycles with demand data read transactions in the superQ",
		  .ucode  = 0x1 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "DEMAND_DATA_RD:c=1",
		},
		{ .uname = "ALL_DATA_RD",
		  .udesc  = "Cacheable data read transactions in the superQ every cycle",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_CODE_RD",
		  .udesc  = "Code read transactions in the superQ every cycle",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_DATA_RD",
		  .udesc  = "Demand data read transactions in the superQ every cycle",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_RFO",
		  .udesc  = "Outstanding RFO (store) transactions in the superQ every cycle",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "DEMAND_RFO_CYCLES",
		  .udesc  = "Cycles with outstanding RFO (store) transactions in the superQ",
		  .ucode  = 0x4 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "DEMAND_RFO:c=1",
		},
	  },
	  .numasks = 8
	},
	{ .name = "OTHER_ASSISTS",
	  .desc = "Tbd",
	  .code = 0xc1,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ITLB_MISS_RETIRED",
		  .udesc  = "Number of instructions that experienced an ITLB miss",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "AVX_TO_SSE",
		  .udesc  = "Number of transitions from AVX-256 to legacy SSE when penalty applicable",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "SSE_TO_AVX",
		  .udesc  = "Number of transitions from legacy SSE to AVX-256 when penalty applicable",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name = "PARTIAL_RAT_STALLS",
	  .desc = "Partial Register Allocation Table stalls",
	  .code = 0x59,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "FLAGS_MERGE_UOP",
		  .udesc  = "Number of flags-merge uops in flight in each cycle",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "CYCLES_FLAGS_MERGE_UOP",
		  .udesc  = "Cycles in which flags-merge uops in flight",
		  .ucode  = 0x20 | (1 << 16), /* cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "FLAGS_MERGE_UOP:c=1",
		},
		{ .uname = "MUL_SINGLE_UOP",
		  .udesc  = "Number of Multiply packed/scalar single precision uops allocated",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "SLOW_LEA_WINDOW",
		  .udesc  = "Number of cycles with at least one slow LEA uop allocated",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "RESOURCE_STALLS",
	  .desc   = "Resource related stall cycles",
	  .code = 0xa2,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ANY",
		  .udesc  = "Cycles stalled due to Resource Related reason",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname = "LB",
		  .udesc  = "Cycles stalled due to lack of load buffers",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RS",
		  .udesc  = "Cycles stalled due to no eligible RS entry available",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "B",
		  .udesc  = "Cycles stalled due to no store buffers available (not including draining from sync)",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ROB",
		  .udesc  = "Cycles stalled due to re-order buffer full",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "FCSW",
		  .udesc  = "Cycles stalled due to writing the FPU control word",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "MXCSR",
		  .udesc  = "Cycles stalled due to the MXCSR register ranme occurring too close to a previous MXCSR rename",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 7
	},
	{ .name = "RESOURCE_STALLS2",
	  .desc   = "Resource related stall cycles",
	  .code = 0x5b,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ALL_FL_EMPTY",
		  .udesc  = "Cycles stalled due to free list empty",
		  .ucode  = 0xc,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "ANY_PRF_CONTROL",
		  .udesc  = "Cycles stalls due to control structures full for physical registers",
		  .ucode  = 0xf,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "BOB_FULL",
		  .udesc  = "Cycles Allocator is stalled due Branch Order Buffer",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "OOO_RSRC",
		  .udesc  = "Cycles stalled due to out of order resources full",
		  .ucode  = 0x4f,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name = "ROB_MISC_EVENTS",
	  .desc = "Reorder buffer events",
	  .code = 0xcc,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "LBR_INSERTS",
		  .udesc  = "Count each time an new LBR record is saved by HW",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO |INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "RS_EVENTS",
	  .desc = "Reservation station events",
	  .code = 0x5e,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "EMPTY_CYCLES",
		  .udesc  = "Cycles the RS is empty for this thread",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO |INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "SQ_MISC",
	  .desc = "SuperQ events",
	  .code = 0xf4,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "SPLIT_LOCK",
		  .udesc  = "Split locks in SQ",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO |INTEL_X86_DFL,
		},
	  },
	  .numasks = 1
	},
	{ .name = "TLB_FLUSH",
	  .desc = "TLB flushes",
	  .code = 0xbd,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "DTLB_THREAD",
		  .udesc  = "Number of DTLB flushes of thread-specific entries",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "STLB_ANY",
		  .udesc  = "Number of STLB flushes",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
	  },
	  .numasks = 2
	},
	{.name = "UNHALTED_CORE_CYCLES", /* architected event */
		.code = 0x003c,
		.cntmsk = 0x20000000full,
		.modmsk = INTEL_FIXED3_ATTRS,
		.desc =  "Count core clock cycles whenever the clock signal on the specific core is running (not halted)",
	},
	{.name = "UNHALTED_REFERENCE_CYCLES", /* architected event */
		.code = 0x013c,
		.cntmsk = 0x400000000ull,
		.modmsk = INTEL_FIXED3_ATTRS,
		.desc =  "Unhalted reference cycles",
	},
	{ .name = "UOPS_DISPATCHED",
	  .desc = "Uops dispatched",
	  .code = 0xb1,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "CORE",
		  .udesc  = "Counts total number of uops dispatched from any thread",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "STALL_CYCLES",
		  .udesc  = "Counts number of cycles no uops were dispatched on this thread",
		  .ucode  = 0x1 | (1<<16) | (1<<15), /* cmask=1, inv=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "THREAD:c=1:i=1",
		},
		{ .uname = "THREAD",
		  .udesc  = "Counts total number of uops to be dispatched per-thread each cycle",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name = "UOPS_DISPATCHED_PORT",
	  .desc = "Uops dispatch to specific ports",
	  .code = 0xa1,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "PORT_0",
		  .udesc  = "Cycles which a Uop is dispatched on port 0",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_1",
		  .udesc  = "Cycles which a Uop is dispatched on port 1",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_2_LD",
		  .udesc  = "Cycles in which a load uop is dispatched on port 2",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_2_STA",
		  .udesc  = "Cycles in which a store uop is dispatched on port 2",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_2",
		  .udesc  = "Cycles in which a uop is dispatched on port 2",
		  .ucode  = 0xc,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_3_LD",
		  .udesc  = "Cycles in which a load uop is disptached on port 3",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_3_STA",
		  .udesc  = "Cycles in which a store uop is disptached on port 3",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_3",
		  .udesc  = "Cycles in which a uop is disptached on port 3",
		  .ucode  = 0x30,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_4",
		  .udesc  = "Cycles which a uop is dispatched on port 4",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "PORT_5",
		  .udesc  = "Cycles which a Uop is dispatched on port 5",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 10
	},
	{ .name = "UOPS_ISSUED",
	  .desc = "Uops issued",
	  .code = 0xe,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .umasks = {
		{ .uname = "ANY",
		  .udesc  = "Number of uops issued by the RAT to the Reservation Station (RS)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname = "CORE_STALL_CYCLES",
		  .udesc  = "Cycles no uops issued on this core (by any thread)",
		  .ucode  = 0x1 | (1 << 13) | (1 << 15) | (1 << 16), /* any=1 inv=1 cmask=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "ANY:c=1:i=1:t=1",
		},
		{ .uname = "STALL_CYCLES",
		  .udesc  = "Cycles no uops issued by this thread",
		  .ucode  = 0x01 | (1<<16) | (1<<15), /* counter-mask=1, inv=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "ANY:c=1:i=1",
		},
	  },
	  .numasks = 3
	},
	{ .name = "UOPS_RETIRED",
	  .desc = "Uops retired",
	  .code = 0xc2,
	  .cntmsk = 0xff,
	  .ngrp = 1,
	  .modmsk = INTEL_V3_ATTRS,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname = "ANY",
		  .udesc  = "All uops that actually retired (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO | INTEL_X86_DFL,
		},
		{ .uname = "MACRO_FUSED",
		  .udesc  = "Number of macro-fused uops retired",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname = "RETIRE_SLOTS",
		  .udesc  = "Number of retirement slots used (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		},
		{ .uname = "STALL_CYCLES",
		  .udesc  = "Cycles no executable uop retired (Precise Event)",
		  .ucode  = 0x01 | (1<<16) | (1<<15), /* counter-mask=1, inv=1 */
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		  .uequiv = "ANY:c=1:i=1",
		},
		{ .uname = "TOTAL_CYCLES",
		  .udesc  = "Total cycles using precise uop retired event (Precise Event)",
		  .ucode  = 0x1 | (16 << 16), /* cmask=16 */
		  .uflags = INTEL_X86_PEBS | INTEL_X86_NCOMBO,
		  .uequiv = "ANY:c=16",
		},
	  },
	  .numasks = 5
	},
	/*
	 * BEGIN OFFCORE_RESPONSE
	 */
	{ .name   = "OFFCORE_RESPONSE_0",
	  .desc   = "Offcore response 0 (must provide at least one request and one response umasks)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code   = 0x01B7,
	  .flags  = INTEL_X86_NHM_OFFCORE,
	  .ngrp = 2,
	  .umasks = {
		{ .uname  = "DMND_DATA_RD",
		  .udesc  = "request: number of demand and DCU prefetch data reads of full and partial cachelines as well as demand data page table entry cacheline reads. Does not count L2 data read prefetches or instruction fetches",
		  .ucode  = 1ULL << 0,
		  .grpid  = 0,
		},
		{ .uname  = "DMND_RFO",
		  .udesc  = "request: number of demand and DCU prefetch reads for ownership (RFO) requests generated by a write to data cacheline. Does not count L2 RFO prefetches",
		  .ucode  = 1ULL << 1,
		  .grpid  = 0,
		},
		{ .uname  = "DMND_IFETCH",
		  .udesc  = "request: number of demand and DCU prefetch instruction cacheline reads. Does not count L2 code read prefetches",
		  .ucode  = 1ULL << 2,
		  .grpid  = 0,
		},
		{ .uname  = "WB",
		  .udesc  = "request: number of writebacks (modified to exclusive) transactions",
		  .ucode  = 1ULL << 3,
		  .grpid  = 0,
		},
		{ .uname  = "PF_DATA_RD",
		  .udesc  = "request: number of data cacheline reads generated by L2 prefetchers",
		  .ucode  = 1ULL << 4,
		  .grpid  = 0,
		},
		{ .uname  = "PF_RFO",
		  .udesc  = "request: number of RFO requests generated by L2 prefetchers",
		  .ucode  = 1ULL << 5,
		  .grpid  = 0,
		},
		{ .uname  = "PF_IFETCH",
		  .udesc  = "request: number of code reads generated by L2 prefetchers",
		  .ucode  = 1ULL << 6,
		  .grpid  = 0,
		},
		{ .uname  = "PF_LLC_DATA_RD",
		  .udesc  = "request: number of L3 prefetcher requests to L2 for loads",
		  .ucode  = 1ULL << 7,
		  .grpid  = 0,
		},
		{ .uname  = "PF_LLC_RFO",
		  .udesc  = "request: number of RFO requests generated by L2 prefetcher",
		  .ucode  = 1ULL << 8,
		  .grpid  = 0,
		},
		{ .uname  = "PF_LLC_IFETCH",
		  .udesc  = "request: number of L2 prefetcher requests to L3 for instruction fetches",
		  .ucode  = 1ULL << 9,
		  .grpid  = 0,
		},
		{ .uname  = "BUS_LOCKS",
		  .udesc  = "request: number bus lock and split lock requests",
		  .ucode  = 1ULL << 10,
		  .grpid  = 0,
		},
		{ .uname  = "STRM_ST",
		  .udesc  = "request: number of streaming store requests",
		  .ucode  = 1ULL << 11,
		  .grpid  = 0,
		},
		{ .uname  = "OTHER",
		  .udesc  = "request: counts one of the following transaction types, including L3 invalidate, I/O, full or partial writes, WC or non-temporal stores, CLFLUSH, Fences, lock, unlock, split lock",
		  .ucode  = 1ULL << 12,
		  .grpid  = 0,
		},
		{ .uname  = "ANY_IFETCH",
		  .udesc  = "request: combination of PF_IFETCH | DMND_IFETCH | PF_LLC_IFETCH",
		  .ucode  = (1ULL << 6) | (1ULL < 2) | (1ULL << 9),
		  .grpid  = 0,
		  .uequiv = "PF_IFETCH:DMND_IFETCH:PF_LLC_IFETCH",
		},
		{ .uname  = "ANY_REQUEST",
		  .udesc  = "request: combination of all request umasks",
		  .ucode  = 0x8fff,
		  .grpid  = 0,
		  .uequiv = "DMND_DATA_RD:DMND_RFO:DMND_IFETCH:WB:PF_DATA_RD:PF_RFO:PF_IFETCH:PF_LLC_DATA_RD:PF_LLC_RFO:PF_LLC_IFETCH:BUS_LOCKS:STRM_ST:OTHER",
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "ANY_DATA",
		  .udesc  = "request: combination of DMND_DATA | PF_DATA_RD | PF_LLC_DATA_RD",
		  .ucode  = (1ULL << 0) | (1ULL << 4) | (1ULL << 7),
		  .grpid  = 0,
		  .uequiv = "DMND_DATA_RD:PF_DATA_RD:PF_LLC_DATA_RD",
		},
		{ .uname  = "ANY_RFO",
		  .udesc  = "request: combination of DMND_RFO | PF_RFO | PF_LLC_RFO",
		  .ucode  = (1ULL << 1) | (1ULL < 5) | (1ULL << 8),
		  .grpid  = 0,
		  .uequiv = "DMND_RFO:PF_RFO:PF_LLC_RFO",
		},


		{ .uname  = "ANY_RESPONSE",
		  .udesc  = "response: count any response type",
		  .ucode  = 1ULL << 16,
		  .grpid  = 1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "NO_SUPP",
		  .udesc  = "response: counts number of times supplier information is not available",
		  .ucode  = 1ULL << 17,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITM",
		  .udesc  = "response: counts L3 hits in M-state (initial lookup)",
		  .ucode  = 1ULL << 18,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITE",
		  .udesc  = "response: counts L3 hits in E-state",
		  .ucode  = 1ULL << 19,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITS",
		  .udesc  = "response: counts L3 hits in S-state",
		  .ucode  = 1ULL << 20,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITF",
		  .udesc  = "response: counts L3 hits in F-state",
		  .ucode  = 1ULL << 21,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_NONE",
		  .udesc  = "response: counts number of times no snoop-related information is available",
		  .ucode  = 1ULL << 31,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_NOT_NEEDED",
		  .udesc  = "response: counts the number of times no snoop was needed to satisfy the request",
		  .ucode  = 1ULL << 32,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_MISS",
		  .udesc  = "response: counts number of times a snoop was needed and it missed all snooped caches",
		  .ucode  = 1ULL << 33,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_NO_FWD",
		  .udesc  = "response: counts number of times a snoop was needed and it hit in at leas one snooped cache",
		  .ucode  = 1ULL << 34,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_FWD",
		  .udesc  = "response: counts number of times a snoop was needed and data was forwarded from a remote socket",
		  .ucode  = 1ULL << 35,
		  .grpid  = 1,
		},
		{ .uname  = "HITM",
		  .udesc  = "response: counts number of times a snoop was needed and it hitM-ed in local or remote cache",
		  .ucode  = 1ULL << 36,
		  .grpid  = 1,
		},
		{ .uname  = "NON_DRAM",
		  .udesc  = "response:  counts number of times target was a non-DRAM system address. This includes MMIO transactions",
		  .ucode  = 1ULL << 37,
		  .grpid  = 1,
		},
	  },
	  .numasks = 30
	},
	{ .name   = "OFFCORE_RESPONSE_1",
	  .desc   = "Offcore response 1 (must provide at least one request and one response umasks)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code   = 0x01BB,
	  .flags  = INTEL_X86_NHM_OFFCORE,
	  .ngrp = 2,
	  .umasks = {
		{ .uname  = "DMND_DATA_RD",
		  .udesc  = "request: number of demand and DCU prefetch data reads of full and partial cachelines as well as demand data page table entry cacheline reads. Does not count L2 data read prefetches or instruction fetches",
		  .ucode  = 1ULL << 0,
		  .grpid  = 0,
		},
		{ .uname  = "DMND_RFO",
		  .udesc  = "request: number of demand and DCU prefetch reads for ownership (RFO) requests generated by a write to data cacheline. Does not count L2 RFO prefetches",
		  .ucode  = 1ULL << 1,
		  .grpid  = 0,
		},
		{ .uname  = "DMND_IFETCH",
		  .udesc  = "request: number of demand and DCU prefetch instruction cacheline reads. Does not count L2 code read prefetches",
		  .ucode  = 1ULL << 2,
		  .grpid  = 0,
		},
		{ .uname  = "WB",
		  .udesc  = "request: number of writebacks (modified to exclusive) transactions",
		  .ucode  = 1ULL << 3,
		  .grpid  = 0,
		},
		{ .uname  = "PF_DATA_RD",
		  .udesc  = "request: number of data cacheline reads generated by L2 prefetchers",
		  .ucode  = 1ULL << 4,
		  .grpid  = 0,
		},
		{ .uname  = "PF_RFO",
		  .udesc  = "request: number of RFO requests generated by L2 prefetchers",
		  .ucode  = 1ULL << 5,
		  .grpid  = 0,
		},
		{ .uname  = "PF_IFETCH",
		  .udesc  = "request: number of code reads generated by L2 prefetchers",
		  .ucode  = 1ULL << 6,
		  .grpid  = 0,
		},
		{ .uname  = "PF_LLC_DATA_RD",
		  .udesc  = "request: number of L3 prefetcher requests to L2 for loads",
		  .ucode  = 1ULL << 7,
		  .grpid  = 0,
		},
		{ .uname  = "PF_LLC_RFO",
		  .udesc  = "request: number of RFO requests generated by L2 prefetcher",
		  .ucode  = 1ULL << 8,
		  .grpid  = 0,
		},
		{ .uname  = "PF_LLC_IFETCH",
		  .udesc  = "request: number of L2 prefetcher requests to L3 for instruction fetches",
		  .ucode  = 1ULL << 9,
		  .grpid  = 0,
		},
		{ .uname  = "BUS_LOCKS",
		  .udesc  = "request: number bus lock and split lock requests",
		  .ucode  = 1ULL << 10,
		  .grpid  = 0,
		},
		{ .uname  = "STRM_ST",
		  .udesc  = "request: number of streaming store requests",
		  .ucode  = 1ULL << 11,
		  .grpid  = 0,
		},
		{ .uname  = "OTHER",
		  .udesc  = "request: counts one of the following transaction types, including L3 invalidate, I/O, full or partial writes, WC or non-temporal stores, CLFLUSH, Fences, lock, unlock, split lock",
		  .ucode  = 1ULL << 12,
		  .grpid  = 0,
		},
		{ .uname  = "ANY_IFETCH",
		  .udesc  = "request: combination of PF_IFETCH | DMND_IFETCH | PF_LLC_IFETCH",
		  .ucode  = (1ULL << 6) | (1ULL < 2) | (1ULL << 9),
		  .grpid  = 0,
		  .uequiv = "PF_IFETCH:DMND_IFETCH:PF_LLC_IFETCH",
		},
		{ .uname  = "ANY_REQUEST",
		  .udesc  = "request: combination of all request umasks",
		  .ucode  = 0x8fff,
		  .grpid  = 0,
		  .uequiv = "DMND_DATA_RD:DMND_RFO:DMND_IFETCH:WB:PF_DATA_RD:PF_RFO:PF_IFETCH:PF_LLC_DATA_RD:PF_LLC_RFO:PF_LLC_IFETCH:BUS_LOCKS:STRM_ST:OTHER",
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "ANY_DATA",
		  .udesc  = "request: combination of DMND_DATA | PF_DATA_RD | PF_LLC_DATA_RD",
		  .ucode  = (1ULL << 0) | (1ULL << 4) | (1ULL << 7),
		  .grpid  = 0,
		  .uequiv = "DMND_DATA_RD:PF_DATA_RD:PF_LLC_DATA_RD",
		},
		{ .uname  = "ANY_RFO",
		  .udesc  = "request: combination of DMND_RFO | PF_RFO | PF_LLC_RFO",
		  .ucode  = (1ULL << 1) | (1ULL < 5) | (1ULL << 8),
		  .grpid  = 0,
		  .uequiv = "DMND_RFO:PF_RFO:PF_LLC_RFO",
		},


		{ .uname  = "ANY_RESPONSE",
		  .udesc  = "response: count any response type",
		  .ucode  = 1ULL << 16,
		  .grpid  = 1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "NO_SUPP",
		  .udesc  = "response: counts number of times supplier information is not available",
		  .ucode  = 1ULL << 17,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITM",
		  .udesc  = "response: counts L3 hits in M-state (initial lookup)",
		  .ucode  = 1ULL << 18,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITE",
		  .udesc  = "response: counts L3 hits in E-state",
		  .ucode  = 1ULL << 19,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITS",
		  .udesc  = "response: counts L3 hits in S-state",
		  .ucode  = 1ULL << 20,
		  .grpid  = 1,
		},
		{ .uname  = "LLC_HITF",
		  .udesc  = "response: counts L3 hits in F-state",
		  .ucode  = 1ULL << 21,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_NONE",
		  .udesc  = "response: counts number of times no snoop-related information is available",
		  .ucode  = 1ULL << 31,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_NOT_NEEDED",
		  .udesc  = "response: counts the number of times no snoop was needed to satisfy the request",
		  .ucode  = 1ULL << 32,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_MISS",
		  .udesc  = "response: counts number of times a snoop was needed and it missed all snooped caches",
		  .ucode  = 1ULL << 33,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_NO_FWD",
		  .udesc  = "response: counts number of times a snoop was needed and it hit in at leas one snooped cache",
		  .ucode  = 1ULL << 34,
		  .grpid  = 1,
		},
		{ .uname  = "SNP_FWD",
		  .udesc  = "response: counts number of times a snoop was needed and data was forwarded from a remote socket",
		  .ucode  = 1ULL << 35,
		  .grpid  = 1,
		},
		{ .uname  = "HITM",
		  .udesc  = "response: counts number of times a snoop was needed and it hitM-ed in local or remote cache",
		  .ucode  = 1ULL << 36,
		  .grpid  = 1,
		},
		{ .uname  = "NON_DRAM",
		  .udesc  = "response:  counts number of times target was a non-DRAM system address. This includes MMIO transactions",
		  .ucode  = 1ULL << 37,
		  .grpid  = 1,
		},
	  },
	  .numasks = 30
	}
};
#define PME_SNB_EVENT_COUNT (sizeof(intel_snb_pe)/sizeof(intel_x86_entry_t))
