.TH "PAPI_flops" 3 "14 Sep 2016" "Version 5.5.0.0" "PAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
PAPI_flops \- 
.PP
Simplified call to get Mflops/s (floating point operation rate), real and processor time.  

.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
\fBC Interface: \fP.RS 4
#include <\fBpapi.h\fP> 
.br
 int PAPI_flops( float *rtime, float *ptime, long long *flpops, float *mflops );
.RE
.PP
\fBParameters:\fP
.RS 4
\fI*rtime\fP total realtime since the first call 
.br
\fI*ptime\fP total process time since the first call 
.br
\fI*flpops\fP total floating point operations since the first call 
.br
\fI*mflops\fP incremental (Mega) floating point operations per seconds since the last call
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPAPI_EINVAL\fP The counters were already started by something other than PAPI_flops(). 
.br
\fIPAPI_ENOEVNT\fP The floating point operations event does not exist. 
.br
\fIPAPI_ENOMEM\fP Insufficient memory to complete the operation.
.RE
.PP
The first call to PAPI_flops() will initialize the PAPI High Level interface, set up the counters to monitor the PAPI_FP_OPS event and start the counters.
.PP
Subsequent calls will read the counters and return total real time, total process time, total floating point operations since the start of the measurement and the Mflop/s rate since latest call to PAPI_flops(). A call to PAPI_stop_counters() will stop the counters from running and then calls such as PAPI_start_counters() or other rate calls can safely be used.
.PP
\fBPAPI_flops\fP returns information related to theoretical floating point operations rather than simple instructions. It uses the PAPI_FP_OPS event which attempts to 'correctly' account for, e.g., FMA undercounts and FP Store overcounts, etc.
.PP
\fBSee also:\fP
.RS 4
PAPI_flips() 
.PP
PAPI_ipc() 
.PP
PAPI_epc() 
.PP
PAPI_stop_counters() 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for PAPI from the source code.
