.TH "PAPI_flips" 3 "14 Sep 2016" "Version 5.5.0.0" "PAPI" \" -*- nroff -*-
.ad l
.nh
.SH NAME
PAPI_flips \- 
.PP
Simplified call to get Mflips/s (floating point instruction rate), real and processor time.  

.SH SYNOPSIS
.br
.PP
.SH "Detailed Description"
.PP 
\fBC Interface: \fP.RS 4
#include <\fBpapi.h\fP> 
.br
 int PAPI_flips( float *rtime, float *ptime, long long *flpins, float *mflips );
.RE
.PP
\fBParameters:\fP
.RS 4
\fI*rtime\fP total realtime since the first call 
.br
\fI*ptime\fP total process time since the first call 
.br
\fI*flpins\fP total floating point instructions since the first call 
.br
\fI*mflips\fP incremental (Mega) floating point instructions per seconds since the last call
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIPAPI_EINVAL\fP The counters were already started by something other than PAPI_flips(). 
.br
\fIPAPI_ENOEVNT\fP The floating point instructions event does not exist. 
.br
\fIPAPI_ENOMEM\fP Insufficient memory to complete the operation.
.RE
.PP
The first call to PAPI_flips() will initialize the PAPI High Level interface, set up the counters to monitor the PAPI_FP_INS event and start the counters.
.PP
Subsequent calls will read the counters and return total real time, total process time, total floating point instructions since the start of the measurement and the Mflip/s rate since latest call to PAPI_flips(). A call to PAPI_stop_counters() will stop the counters from running and then calls such as PAPI_start_counters() or other rate calls can safely be used.
.PP
\fBPAPI_flips\fP returns information related to floating point instructions using the PAPI_FP_INS event. This is intended to measure instruction rate through the floating point pipe with no massaging.
.PP
\fBSee also:\fP
.RS 4
PAPI_flops() 
.PP
PAPI_ipc() 
.PP
PAPI_epc() 
.PP
PAPI_stop_counters() 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for PAPI from the source code.
