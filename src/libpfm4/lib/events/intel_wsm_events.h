/*
 * Copyright (c) 2009 Google, Inc
 * Contributed by Stephane Eranian <eranian@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of libpfm, a performance monitoring support library for
 * applications on Linux.
 */
static const intel_x86_entry_t intel_wsm_pe[]={
	/*
	 * BEGIN architected events
	 */
	{.name = "UNHALTED_CORE_CYCLES",
		.code = 0x003c,
		.cntmsk = 0x20000000full,
		.modmsk = INTEL_V3_ATTRS, /* because we can fallback to generic counter */
		.desc =  "count core clock cycles whenever the clock signal on the specific core is running (not halted).",
		.equiv = "CPU_CLK_UNHALTED:THREAD_P",
	},
	{.name = "INSTRUCTION_RETIRED",
		.code = 0x00c0,
		.cntmsk = 0x10000000full,
		.modmsk = INTEL_V3_ATTRS, /* because we can fallback to generic counter */
		.desc =  "count the number of instructions at retirement.",
		.equiv = "INST_RETIRED:ANY_P",
	},
	{.name = "INSTRUCTIONS_RETIRED",
		.code = 0x00c0,
		.cntmsk = 0x10000000full,
		.modmsk = INTEL_V3_ATTRS, /* because we can fallback to generic counter */
		.desc =  "This is an alias for INSTRUCTION_RETIRED",
		.equiv = "INST_RETIRED:ANY_P",
	},
	{.name = "UNHALTED_REFERENCE_CYCLES",
		.code = 0x013c,
		.cntmsk = 0x400000000ull,
		.modmsk = INTEL_FIXED3_ATTRS,
		.desc =  "Unhalted reference cycles",
	},
	{.name = "LLC_REFERENCES",
		.code = 0x4f2e,
		.cntmsk = 0xf,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "count each request originating from the core to reference a cache line in the last level cache. The count may include speculation, but excludes cache line fills due to hardware prefetch.",
		.equiv = "L3_LAT_CACHE:REFERENCE"
	},
	{.name = "LAST_LEVEL_CACHE_REFERENCES",
		.code = 0x4f2e,
		.cntmsk = 0xf,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "This is an alias for LLC_REFERENCES",
		.equiv = "L3_LAT_CACHE:REFERENCE"
	},
	{.name = "LLC_MISSES",
		.code = 0x412e,
		.cntmsk = 0xf,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "count each cache miss condition for references to the last level cache. The event count may include speculation, but excludes cache line fills due to hardware prefetch.",
		.equiv = "L3_LAT_CACHE:MISS"
	},
	{.name = "LAST_LEVEL_CACHE_MISSES",
		.code = 0x412e,
		.cntmsk = 0xf,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "This is an alias for LLC_MISSES",
		.equiv = "L3_LAT_CACHE:MISS"
	},
	{.name = "BRANCH_INSTRUCTIONS_RETIRED",
		.code = 0x00c4,
		.cntmsk = 0xf,
		.modmsk = INTEL_V3_ATTRS,
		.desc =  "count branch instructions at retirement. Specifically, this event counts the retirement of the last micro-op of a branch instruction.",
		.equiv = "BR_INST_RETIRED:ALL_BRANCHES",
	},
	/*
	 * BEGIN core specific events
	 */
	{ .name   = "UOPS_DECODED",
	  .desc   = "micro-ops decoded",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xD1,
	  .umasks = {
		{ .uname  = "ESP_FOLDING",
		  .udesc  = "Stack pointer instructions decoded",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "ESP_SYNC",
		  .udesc  = "Stack pointer sync operations",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "MS_CYCLES_ACTIVE",
		  .udesc  = "Uops decoded by Microcode Sequencer",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "STALL_CYCLES",
		  .udesc  = "Cycles no Uops are decoded",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name   = "L1D_CACHE_LOCK_FB_HIT",
	  .desc   = "L1D cacheable load lock speculated or retired accepted into the fill buffer",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x0153,
	  .flags  = 0,
	},
	{ .name   = "BPU_CLEARS",
	  .desc   = "Branch Prediciton Unit clears",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xE8,
	  .umasks = {
		{ .uname  = "EARLY",
		  .udesc  = "Early Branch Prediciton Unit clears",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LATE",
		  .udesc  = "Late Branch Prediction Unit clears",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "UOPS_RETIRED",
	  .desc   = "Cycles Uops are being retired (Precise Event)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xC2,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "Uops retired (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "MACRO_FUSED",
		  .udesc  = "Macro-fused Uops retired (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RETIRE_SLOTS",
		  .udesc  = "Retirement slots used (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "STALL_CYCLES",
		  .udesc  = "Cycles Uops are not retiring (Precise Event)",
		  .ucode  = 0x01 | (1<<16) | (1<<15), /* cmask=1, inv=1 */
		  .modhw = _INTEL_X86_ATTR_C|INTEL_X86_ATTR_I,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "ANY:c=1:i=1",
		},
		{ .uname  = "TOTAL_CYCLES",
		  .udesc  = "Total cycles using precise uop retired event (Precise Event)",
		  .ucode  = 0x01 | (1<< 16), /* counter mask = 1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .modhw = _INTEL_X86_ATTR_C,
		  .uequiv = "ANY:c=1",
		},
		{ .uname  = "ACTIVE_CYCLES",
		  .udesc  = "Alias for TOTAL_CYCLES (Precise Event)",
		  .ucode  = 0x01 | (1<< 16), /* counter mask = 1 */
		  .modhw = _INTEL_X86_ATTR_C,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "ANY:c=1",
		},
	  },
	  .numasks = 6
	},
	{ .name   = "BR_MISP_RETIRED",
	  .desc   = "Mispredicted retired branches",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xC5,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "ALL_BRANCHES",
		  .udesc  = "Mispredicted retired branch instructions",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "NEAR_CALL",
		  .udesc  = "Mispredicted near retired calls",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "CONDITIONAL",
		  .udesc  = "Mispredicted conditional branches retired",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		}
	  },
	  .numasks = 3
	},
	{ .name   = "EPT",
	  .desc   = "Extended Page Table",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x4F,
	  .umasks = {
		{ .uname  = "WALK_CYCLES",
		  .udesc  = "Extended Page Table walk cycles",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "EPDE_HIT",
		  .udesc  = "counts hits of extended PDE cache",
		  .ucode  = 0x01,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "UOPS_EXECUTED",
	  .desc   = "micro-ops executed",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xB1,
	  .umasks = {
		{ .uname  = "PORT0",
		  .udesc  = "Uops executed on port 0 (integer arithmetic, SIMD and FP add uops)",
		  .ucode  = 0x01,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT1",
		  .udesc  = "Uops executed on port 1 (integer arithmetic, SIMD, integer shift, FP multiply, FP divide uops)",
		  .ucode  = 0x02,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT2_CORE",
		  .udesc  = "Uops executed on port 2 (load uops) (core count only)",
		  .ucode  = 0x04,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT3_CORE",
		  .udesc  = "Uops executed on port 3 (store uops) (core count only)",
		  .ucode  = 0x08,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT4_CORE",
		  .udesc  = "Uops executed on port 4 (handle store values for stores on port 3) (core count only)",
		  .ucode  = 0x10,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT5",
		  .udesc  = "Uops executed on port 5",
		  .ucode  = 0x20,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT015",
		  .udesc  = "Uops issued on ports 0, 1 or 5",
		  .ucode  = 0x40,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT234_CORE",
		  .udesc  = "Uops issued on ports 2, 3 or 4 (core count only)",
		  .ucode  = 0x80,
	  	  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PORT015_STALL_CYCLES",
		  .udesc  = "Cycles no Uops issued on ports 0, 1 or 5",
		  .ucode  = 0x40 | (1<<16) | (1<<15), /* counter-mask=1, inv=1 */
		  .modhw = _INTEL_X86_ATTR_C|_INTEL_X86_ATTR_I,
	  	  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "PORT015:c=1:i=1",
		},
	  },
	  .numasks = 9
	},
	{ .name   = "IO_TRANSACTIONS",
	  .desc   = "I/O transactions",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x016C,
	  .flags  = 0,
	},
	{ .name   = "ES_REG_RENAMES",
	  .desc   = "ES segment renames",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x01D5,
	  .flags  = 0,
	},
	{ .name   = "INST_RETIRED",
	  .desc   = "Instructions retired",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xC0,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
			{ .uname  = "ANY_P",
				.udesc  = "Instructions Retired (Precise Event)",
				.ucode  = 0x00,
				.uflags = 0,
			},
			{ .uname  = "X87",
				.udesc  = "Retired floating-point operations (Precise Event)",
				.ucode  = 0x02,
				.uflags = 0,
			},
			{ .uname  = "MMX",
		  		.udesc  = "Retired MMX instructions (Precise Event)",
		  		.ucode  = 0x4,
		  		.uflags = 0,
			},
		},
		.numasks = 3
	},
	{ .name   = "ILD_STALL",
	  .desc   = "Instruction Length Decoder stalls",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x87,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "Any Instruction Length Decoder stall cycles",
		  .ucode  = 0xF,
		  .uflags = INTEL_X86_DFL,
		  .uequiv = "IQ_FULL:LCP:MRU:REGEN",
		},
		{ .uname  = "IQ_FULL",
		  .udesc  = "Instruction Queue full stall cycles",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LCP",
		  .udesc  = "Length Change Prefix stall cycles",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "MRU",
		  .udesc  = "Stall cycles due to BPU MRU bypass",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "REGEN",
		  .udesc  = "Regen stall cycles",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name   = "DTLB_LOAD_MISSES",
	  .desc   = "DTLB load misses",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x8,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "DTLB load misses",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "PDE_MISS",
		  .udesc  = "DTLB load miss caused by low part of address",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "STLB_HIT",
		  .udesc  = "DTLB second level hit",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "WALK_COMPLETED",
		  .udesc  = "DTLB load miss page walks complete",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "WALK_CYCLES",
		  .udesc  = "DTLB load miss page walk cycles",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name   = "L2_LINES_IN",
	  .desc   = "L2 lines alloacated",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xF1,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "L2 lines alloacated",
		  .ucode  = 0x7,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "E_STATE",
		  .udesc  = "L2 lines allocated in the E state",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "S_STATE",
		  .udesc  = "L2 lines allocated in the S state",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "SSEX_UOPS_RETIRED",
	  .desc   = "SIMD micro-ops retired (Precise Event)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xC7,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "PACKED_DOUBLE",
		  .udesc  = "SIMD Packed-Double Uops retired (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PACKED_SINGLE",
		  .udesc  = "SIMD Packed-Single Uops retired (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SCALAR_DOUBLE",
		  .udesc  = "SIMD Scalar-Double Uops retired (Precise Event)",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SCALAR_SINGLE",
		  .udesc  = "SIMD Scalar-Single Uops retired (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "VECTOR_INTEGER",
		  .udesc  = "SIMD Vector Integer Uops retired (Precise Event)",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name   = "STORE_BLOCKS",
	  .desc   = "Load delayed by block code",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x6,
	  .umasks = {
		{ .uname  = "AT_RET",
		  .udesc  = "Loads delayed with at-Retirement block code",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "L1D_BLOCK",
		  .udesc  = "Cacheable loads delayed with L1D block code",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "FP_MMX_TRANS",
	  .desc   = "Floating Point to and from MMX transitions",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xCC,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "All Floating Point to and from MMX transitions",
		  .ucode  = 0x3,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "TO_FP",
		  .udesc  = "Transitions from MMX to Floating Point instructions",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "TO_MMX",
		  .udesc  = "Transitions from Floating Point to MMX instructions",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "CACHE_LOCK_CYCLES",
	  .desc   = "Cache locked",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0x3,
	  .ngrp = 1,
	  .code = 0x63,
	  .umasks = {
		{ .uname  = "L1D",
		  .udesc  = "Cycles L1D locked",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "L1D_L2",
		  .udesc  = "Cycles L1D and L2 locked",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "OFFCORE_REQUESTS_SQ_FULL",
	  .desc   = "Offcore requests blocked due to Super Queue full",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x01B2,
	  .flags  = 0,
	},
	{ .name   = "L3_LAT_CACHE",
	  .desc   = "Last level cache accesses",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x2E,
	  .umasks = {
		{ .uname  = "MISS",
		  .udesc  = "Last level cache miss",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "REFERENCE",
		  .udesc  = "Last level cache reference",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "SIMD_INT_64",
	  .desc   = "SIMD 64-bit integer operations",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xFD,
	  .umasks = {
		{ .uname  = "PACK",
		  .udesc  = "SIMD integer 64 bit pack operations",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		  .uflags = 0,
		},
		{ .uname  = "PACKED_ARITH",
		  .udesc  = "SIMD integer 64 bit arithmetic operations",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		  .uflags = 0,
		},
		{ .uname  = "PACKED_LOGICAL",
		  .udesc  = "SIMD integer 64 bit logical operations",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PACKED_MPY",
		  .udesc  = "SIMD integer 64 bit packed multiply operations",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PACKED_SHIFT",
		  .udesc  = "SIMD integer 64 bit shift operations",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SHUFFLE_MOVE",
		  .udesc  = "SIMD integer 64 bit shuffle/move operations",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "UNPACK",
		  .udesc  = "SIMD integer 64 bit unpack operations",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 7
	},
	{ .name   = "BR_INST_DECODED",
	  .desc   = "Branch instructions decoded",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x01E0,
	  .flags  = 0,
	},
	{ .name   = "BR_MISP_EXEC",
	  .desc   = "Mispredicted branches executed",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x89,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "Mispredicted branches executed",
		  .ucode  = 0x7F,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "COND",
		  .udesc  = "Mispredicted conditional branches executed",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DIRECT",
		  .udesc  = "Mispredicted unconditional branches executed",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DIRECT_NEAR_CALL",
		  .udesc  = "Mispredicted non call branches executed",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "INDIRECT_NEAR_CALL",
		  .udesc  = "Mispredicted indirect call branches executed",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "INDIRECT_NON_CALL",
		  .udesc  = "Mispredicted indirect non call branches executed",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "NEAR_CALLS",
		  .udesc  = "Mispredicted call branches executed",
		  .ucode  = 0x30,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "NON_CALLS",
		  .udesc  = "Mispredicted non call branches executed",
		  .ucode  = 0x7,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RETURN_NEAR",
		  .udesc  = "Mispredicted return branches executed",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "TAKEN",
		  .udesc  = "Mispredicted taken branches executed",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 10
	},
	{ .name   = "SQ_FULL_STALL_CYCLES",
	  .desc   = "Super Queue full stall cycles",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x01F6,
	  .flags  = 0,
	},
	{ .name   = "BACLEAR",
	  .desc   = "Branch address calculator clears",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xE6,
	  .umasks = {
		{ .uname  = "BAD_TARGET",
		  .udesc  = "BACLEAR asserted with bad target address",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "CLEAR",
		  .udesc  = "BACLEAR asserted, regardless of cause",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "DTLB_MISSES",
	  .desc   = "Data TLB misses",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x49,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "DTLB misses",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "LARGE_WALK_COMPLETED",
		  .udesc  = "DTLB miss large page walks",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "STLB_HIT",
		  .udesc  = "DTLB first level misses but second level hit",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "WALK_COMPLETED",
		  .udesc  = "DTLB miss page walks",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "WALK_CYCLES",
		  .udesc  = "DTLB miss page walk cycles",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name   = "MEM_INST_RETIRED",
	  .desc   = "Memory instructions retired",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .flags = INTEL_X86_PEBS,
	  .ngrp = 1,
	  .code = 0x0B,
	  .umasks = {
		{ .uname  = "LATENCY_ABOVE_THRESHOLD",
		  .udesc  = "Memory instructions retired above programmed clocks, minimum value threshold is 4, requires PEBS",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOADS",
		  .udesc  = "Instructions retired which contains a load (Precise Event)",
		  .ucode  = 0x01,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "STORES",
		  .udesc  = "Instructions retired which contains a store (Precise Event)",
		  .ucode  = 0x02,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "UOPS_ISSUED",
	  .desc   = "Uops issued",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x0E,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "Uops issued",
		  .ucode  = 0x01,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "STALLED_CYCLES",
		  .udesc  = "Cycles stalled no issued uops",
		  .ucode  = 0x01 | (1<<16) | (1<<15), /* counter-mask=1, inv=1 */
		  .modhw = _INTEL_X86_ATTR_C|_INTEL_X86_ATTR_I,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "ANY:c=1:i=1",
		},
		{ .uname  = "FUSED",
		  .udesc  = "Fused Uops issued",
		  .ucode  = 0x02,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "L2_RQSTS",
	  .desc   = "L2 requests",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x24,
	  .umasks = {
		{ .uname  = "IFETCH_HIT",
		  .udesc  = "L2 instruction fetch hits",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "IFETCH_MISS",
		  .udesc  = "L2 instruction fetch misses",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "IFETCHES",
		  .udesc  = "L2 instruction fetches",
		  .ucode  = 0x30,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LD_HIT",
		  .udesc  = "L2 load hits",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LD_MISS",
		  .udesc  = "L2 load misses",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOADS",
		  .udesc  = "L2 requests",
		  .ucode  = 0x3,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "MISS",
		  .udesc  = "All L2 misses",
		  .ucode  = 0xAA,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_HIT",
		  .udesc  = "L2 prefetch hits",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_MISS",
		  .udesc  = "L2 prefetch misses",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCHES",
		  .udesc  = "All L2 prefetches",
		  .ucode  = 0xC0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "REFERENCES",
		  .udesc  = "All L2 requests",
		  .ucode  = 0xFF,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO_HIT",
		  .udesc  = "L2 RFO hits",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO_MISS",
		  .udesc  = "L2 RFO misses",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFOS",
		  .udesc  = "L2 RFO requests",
		  .ucode  = 0xC,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 14
	},
	{ .name   = "TWO_UOP_INSTS_DECODED",
	  .desc   = "Two Uop instructions decoded",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x0119,
	  .flags  = 0,
	},
	{ .name   = "LOAD_DISPATCH",
	  .desc   = "Loads dispatched",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x13,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "All loads dispatched",
		  .ucode  = 0x7,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "RS",
		  .udesc  = "Number of loads dispatched from the Reservation Station (RS) that bypass the Memory Order Buffer",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RS_DELAYED",
		  .udesc  = "Number of delayed RS dispatches at the stage latch",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "MOB",
		  .udesc  = "Number of loads dispatched from Reservation Station (RS)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name   = "BACLEAR_FORCE_IQ",
	  .desc   = "BACLEAR forced by Instruction queue",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x01A7,
	  .flags  = 0,
	},
	{ .name   = "SNOOPQ_REQUESTS",
	  .desc   = "Snoopq requests",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xB4,
	  .umasks = {
		{ .uname  = "CODE",
		  .udesc  = "Snoop code requests",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DATA",
		  .udesc  = "Snoop data requests",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "INVALIDATE",
		  .udesc  = "Snoop invalidate requests",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "OFFCORE_REQUESTS",
	  .desc   = "offcore requests",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xB0,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "All offcore requests",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "ANY_READ",
		  .udesc  = "Offcore read requests",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "ANY_RFO",
		  .udesc  = "Offcore RFO requests",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_READ_CODE",
		  .udesc  = "Offcore demand code read requests",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_READ_DATA",
		  .udesc  = "Offcore demand data read requests",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_RFO",
		  .udesc  = "Offcore demand RFO requests",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "L1D_WRITEBACK",
		  .udesc  = "Offcore L1 data cache writebacks",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 7
	},
	{ .name   = "LOAD_BLOCK",
	  .desc   = "Loads blocked",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x3,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "OVERLAP_STORE",
		  .udesc  = "lods that partially overlap an earlier store",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name   = "MISALIGN_MEMORY",
	  .desc   = "Misaligned accesses",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x5,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "STORE",
		  .udesc  = "store referenced with misaligned address",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name   = "INST_QUEUE_WRITE_CYCLES",
	  .desc   = "Cycles instructions are written to the instruction queue",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x011E,
	  .flags  = 0,
	},
	{ .name   = "LSD_OVERFLOW",
	  .desc   = "Number of loops that cannot stream from the instruction queue.",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x0120,
	  .flags  = 0,
	},

	{ .name   = "MACHINE_CLEARS",
	  .desc   = "Machine clear asserted",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xC3,
	  .umasks = {
                { .uname  = "MEM_ORDER",
		  .udesc  = "Execution pipeline restart due to Memory ordering conflicts ",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "CYCLES",
		  .udesc  = "cycles machine clear is asserted",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "FP_COMP_OPS_EXE",
	  .desc   = "SSE/MMX micro-ops",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x10,
	  .umasks = {
		{ .uname  = "MMX",
		  .udesc  = "MMX Uops",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SSE_DOUBLE_PRECISION",
		  .udesc  = "SSE FP double precision Uops",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SSE_FP",
		  .udesc  = "SSE and SSE2 FP Uops",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SSE_FP_PACKED",
		  .udesc  = "SSE FP packed Uops",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SSE_FP_SCALAR",
		  .udesc  = "SSE FP scalar Uops",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SSE_SINGLE_PRECISION",
		  .udesc  = "SSE FP single precision Uops",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SSE2_INTEGER",
		  .udesc  = "SSE2 integer Uops",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "X87",
		  .udesc  = "Computational floating-point operations executed",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 8
	},
	{ .name   = "ITLB_FLUSH",
	  .desc   = "ITLB flushes",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x01AE,
	  .flags  = 0,
	},
	{ .name   = "BR_INST_RETIRED",
	  .desc   = "Retired branch instructions (Precise Event)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xC4,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "ALL_BRANCHES",
		  .udesc  = "Retired branch instructions (Precise Event)",
		  .ucode  = 0x0,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "CONDITIONAL",
		  .udesc  = "Retired conditional branch instructions (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "NEAR_CALL",
		  .udesc  = "Retired near call instructions (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "L1D_CACHE_PREFETCH_LOCK_FB_HIT",
	  .desc   = "L1D prefetch load lock accepted in fill buffer",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x0152,
	  .flags  = 0,
	},
	{ .name   = "LARGE_ITLB",
	  .desc   = "Large ITLB accesses",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x82,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "HIT",
		  .udesc  = "Large ITLB hit",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name   = "LSD",
	  .desc   = "Loop stream detector",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xA8,
	  .umasks = {
		{ .uname  = "UOPS",
		  .udesc  = "counts the number of micro-ops delivered by LSD",
		  .ucode  = 0x01,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "ACTIVE",
		  .udesc  = "Cycles is which at least one micro-op delivered by LSD",
		  .ucode  = 0x01 | (1<<16),
		  .modhw = _INTEL_X86_ATTR_C,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "UOPS:c=1",
		},
	  },
	  .numasks = 2
	},
	{ .name   = "L2_LINES_OUT",
	  .desc   = "L2 lines evicted",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xF2,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "L2 lines evicted",
		  .ucode  = 0xF,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_CLEAN",
		  .udesc  = "L2 lines evicted by a demand request",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_DIRTY",
		  .udesc  = "L2 modified lines evicted by a demand request",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_CLEAN",
		  .udesc  = "L2 lines evicted by a prefetch request",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_DIRTY",
		  .udesc  = "L2 modified lines evicted by a prefetch request",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name   = "ITLB_MISSES",
	  .desc   = "ITLB miss",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x85,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "ITLB miss",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "WALK_COMPLETED",
		  .udesc  = "ITLB miss page walks",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "WALK_CYCLES",
		  .udesc  = "ITLB miss page walk cycles",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LARGE_WALK_COMPLETED",
		  .udesc  = "Number of completed large page walks due to misses in the STLB",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name   = "L1D_PREFETCH",
	  .desc   = "L1D hardware prefetch",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x4E,
	  .umasks = {
		{ .uname  = "MISS",
		  .udesc  = "L1D hardware prefetch misses",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "REQUESTS",
		  .udesc  = "L1D hardware prefetch requests",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "TRIGGERS",
		  .udesc  = "L1D hardware prefetch requests triggered",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "SQ_MISC",
	  .desc   = "Super Queue miscellaneous",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xF4,
	  .umasks = {
		{ .uname  = "LRU_HINTS",
		  .udesc  = "Super Queue LRU hints sent to LLC",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SPLIT_LOCK",
		  .udesc  = "Super Queue lock splits across a cache line",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "SEG_RENAME_STALLS",
	  .desc   = "Segment rename stall cycles",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x01D4,
	  .flags  = 0,
	},
	{ .name   = "FP_ASSIST",
	  .desc   = "X87 Floating point assists (Precise Event)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xF7,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "ALL",
		  .udesc  = "All X87 Floating point assists (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "INPUT",
		  .udesc  = "X87 Floating point assists for invalid input value (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "OUTPUT",
		  .udesc  = "X87 Floating point assists for invalid output value (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "SIMD_INT_128",
	  .desc   = "128 bit SIMD operations",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x12,
	  .umasks = {
		{ .uname  = "PACK",
		  .udesc  = "128 bit SIMD integer pack operations",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PACKED_ARITH",
		  .udesc  = "128 bit SIMD integer arithmetic operations",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PACKED_LOGICAL",
		  .udesc  = "128 bit SIMD integer logical operations",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PACKED_MPY",
		  .udesc  = "128 bit SIMD integer multiply operations",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PACKED_SHIFT",
		  .udesc  = "128 bit SIMD integer shift operations",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "SHUFFLE_MOVE",
		  .udesc  = "128 bit SIMD integer shuffle/move operations",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "UNPACK",
		  .udesc  = "128 bit SIMD integer unpack operations",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 7
	},
	{ .name   = "OFFCORE_REQUESTS_OUTSTANDING",
	  .desc   = "Outstanding offcore requests",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x60,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "ANY_READ",
		  .udesc  = "Outstanding offcore reads",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_READ_CODE",
		  .udesc  = "Outstanding offcore demand code reads",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_READ_DATA",
		  .udesc  = "Outstanding offcore demand data reads",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_RFO",
		  .udesc  = "Outstanding offcore demand RFOs",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name   = "MEM_STORE_RETIRED",
	  .desc   = "Retired stores",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xC,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "DTLB_MISS",
		  .udesc  = "Retired stores that miss the DTLB (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name   = "INST_DECODED",
	  .desc   = "Instructions decoded",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x18,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "DEC0",
		  .udesc  = "Instructions that must be decoded by decoder 0",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name   = "MACRO_INSTS_FUSIONS_DECODED",
	  .desc   = "Count the number of instructions decoded that are macros-fused but not necessarily executed or retired",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code   = 0x01A6,
	  .flags  = 0,
	},
	{ .name   = "MACRO_INSTS",
	  .desc   = "macro-instructions",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xD0,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "DECODED",
		  .udesc  = "Instructions decoded",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name   = "PARTIAL_ADDRESS_ALIAS",
	  .desc   = "False dependencies due to partial address aliasing",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code = 0x0107,
	  .flags  = 0,
	},
	{ .name   = "ARITH",
	  .desc   = "Counts arithmetic multiply and divide operations",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x14,
	  .umasks = {
		{ .uname  = "CYCLES_DIV_BUSY",
		  .udesc  = "Counts the number of cycles the divider is busy executing divide or square root operations. The divide can be integer, X87 or Streaming SIMD Extensions (SSE). The square root operation can be either X87 or SSE. Count may be incorrect when HT is on",
		  .ucode  = 0x01,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DIV",
		  .udesc  = "Counts the number of divide or square root operations. The divide can be integer, X87 or Streaming SIMD Extensions (SSE). The square root operation can be either X87 or SSE. Count may be incorrect when HT is on",
		  .ucode  = 0x01 | (1<<16) | (1<<15) | (1<<10),    /* cmask=1, invert=1, edge=1 */
		  .uflags = INTEL_X86_NCOMBO,
		  .modhw = _INTEL_X86_ATTR_C|_INTEL_X86_ATTR_I|_INTEL_X86_ATTR_E,
		  .uequiv = "CYCLES_DIV_BUSY:c=1:i=1:e=1",
		},
		{ .uname  = "MUL",
		  .udesc  = "Counts the number of multiply operations executed. This includes integer as well as floating point multiply operations but excludes DPPS mul and MPSAD. Count may be incorrect when HT is on",
		  .ucode  = 0x02,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "L2_TRANSACTIONS",
	  .desc   = "All L2 transactions",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xF0,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "All L2 transactions",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "FILL",
		  .udesc  = "L2 fill transactions",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "IFETCH",
		  .udesc  = "L2 instruction fetch transactions",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "L1D_WB",
		  .udesc  = "L1D writeback to L2 transactions",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOAD",
		  .udesc  = "L2 Load transactions",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH",
		  .udesc  = "L2 prefetch transactions",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO",
		  .udesc  = "L2 RFO transactions",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "WB",
		  .udesc  = "L2 writeback to LLC transactions",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 8
	},
	{ .name   = "INST_QUEUE_WRITES",
	  .desc   = "Instructions written to instruction queue.",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code   = 0x0117,
	  .flags  = 0,
	},
	{ .name   = "SB_DRAIN",
	  .desc   = "store buffer",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x4,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "All Store buffer stall cycles",
		  .ucode  = 0x7,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 1
	},
	{ .name   = "LOAD_HIT_PRE",
	  .desc   = "Load operations conflicting with software prefetches",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0x3,
	  .code   = 0x014C,
	  .flags  = 0,
	},
	{ .name   = "MEM_UNCORE_RETIRED",
	  .desc   = "Load instructions retired",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xF,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "LOCAL_HITM",
		  .udesc  = "Load instructions retired that HIT modified data in sibling core (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOCAL_DRAM_AND_REMOTE_CACHE_HIT",
		  .udesc  = "Load instructions retired local dram and remote cache HIT data sources (Precise Event)",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "REMOTE_DRAM",
		  .udesc  = "Load instructions retired remote DRAM and remote home-remote cache HITM (Precise Event)",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "UNCACHEABLE",
		  .udesc  = "Load instructions retired IO (Precise Event)",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOCAL_DRAM",
		  .udesc  = "Retired loads with a data source of local DRAM or locally homed remote cache HITM (Precise Event)",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{ .name   = "L2_DATA_RQSTS",
	  .desc   = "All L2 data requests",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x26,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "All L2 data requests",
		  .ucode  = 0xFF,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_E_STATE",
		  .udesc  = "L2 data demand loads in E state",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_I_STATE",
		  .udesc  = "L2 data demand loads in I state (misses)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_M_STATE",
		  .udesc  = "L2 data demand loads in M state",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_MESI",
		  .udesc  = "L2 data demand requests",
		  .ucode  = 0xF,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DEMAND_S_STATE",
		  .udesc  = "L2 data demand loads in S state",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_E_STATE",
		  .udesc  = "L2 data prefetches in E state",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_I_STATE",
		  .udesc  = "L2 data prefetches in the I state (misses)",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_M_STATE",
		  .udesc  = "L2 data prefetches in M state",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_MESI",
		  .udesc  = "All L2 data prefetches",
		  .ucode  = 0xF0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "PREFETCH_S_STATE",
		  .udesc  = "L2 data prefetches in the S state",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 11
	},
	{ .name   = "BR_INST_EXEC",
	  .desc   = "Branch instructions executed",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x88,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "Branch instructions executed",
		  .ucode  = 0x7F,
	  	  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "COND",
		  .udesc  = "Conditional branch instructions executed",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DIRECT",
		  .udesc  = "Unconditional branches executed",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DIRECT_NEAR_CALL",
		  .udesc  = "Unconditional call branches executed",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "INDIRECT_NEAR_CALL",
		  .udesc  = "Indirect call branches executed",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "INDIRECT_NON_CALL",
		  .udesc  = "Indirect non call branches executed",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "NEAR_CALLS",
		  .udesc  = "Call branches executed",
		  .ucode  = 0x30,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "NON_CALLS",
		  .udesc  = "All non call branches executed",
		  .ucode  = 0x7,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RETURN_NEAR",
		  .udesc  = "Indirect return branches executed",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "TAKEN",
		  .udesc  = "Taken branches executed",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 10
	},
	{ .name   = "ITLB_MISS_RETIRED",
	  .desc   = "Retired instructions that missed the ITLB (Precise Event)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code   = 0x20C8,
	  .flags  = INTEL_X86_PEBS,
	},
	{ .name   = "BPU_MISSED_CALL_RET",
	  .desc   = "Branch prediction unit missed call or return",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .code   = 0x01E5,
	  .flags  = 0,
	},
	{ .name   = "SNOOPQ_REQUESTS_OUTSTANDING",
	  .desc   = "Outstanding snoop requests",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0x1,
	  .ngrp = 1,
	  .code = 0xB3,
	  .umasks = {
		{ .uname  = "CODE",
		  .udesc  = "Outstanding snoop code requests",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "CODE_NOT_EMPTY",
		  .udesc  = "Cycles snoop code requests queue not empty",
		  .ucode  = 0x4 | (1 << 16), /* cmask=1 */
		  .modhw = _INTEL_X86_ATTR_C,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "CODE:c=1",
		},
		{ .uname  = "DATA",
		  .udesc  = "Outstanding snoop data requests",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "DATA_NOT_EMPTY",
		  .udesc  = "Cycles snoop data requests queue not empty",
		  .ucode  = 0x1 | (1 << 16), /* cmask=1 */
		  .modhw = _INTEL_X86_ATTR_C,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "DATA:c=1",
		},
		{ .uname  = "INVALIDATE",
		  .udesc  = "Outstanding snoop invalidate requests",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "INVALIDATE_NOT_EMPTY",
		  .udesc  = "Cycles snoop invalidate requests queue not empty",
		  .ucode  = 0x2 | (1 << 16), /* cmask=1 */
		  .modhw = _INTEL_X86_ATTR_C,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "INVALIDATE:c=1",
		},
	  },
	  .numasks = 6
	},
	{ .name   = "MEM_LOAD_RETIRED",
	  .desc   = "Memory loads retired (Precise Event)",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xCB,
	  .flags = INTEL_X86_PEBS,
	  .umasks = {
		{ .uname  = "DTLB_MISS",
		  .udesc  = "Retired loads that miss the DTLB (Precise Event)",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "HIT_LFB",
		  .udesc  = "Retired loads that miss L1D and hit an previously allocated LFB (Precise Event)",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "L1D_HIT",
		  .udesc  = "Retired loads that hit the L1 data cache (Precise Event)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "L2_HIT",
		  .udesc  = "Retired loads that hit the L2 cache (Precise Event)",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "L3_MISS",
		  .udesc  = "Retired loads that miss the LLC cache (Precise Event)",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LLC_MISS",
		  .udesc  = "This is an alias for L3_MISS",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "L3_MISS",
		},
		{ .uname  = "L3_UNSHARED_HIT",
		  .udesc  = "Retired loads that hit valid versions in the LLC cache (Precise Event)",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LLC_UNSHARED_HIT",
		  .udesc  = "This is an alias for L3_UNSHARED_HIT",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		  .uequiv = "L3_UNSHARED_HIT",
		},
		{ .uname  = "OTHER_CORE_L2_HIT_HITM",
		  .udesc  = "Retired loads that hit sibling core's L2 in modified or unmodified states (Precise Event)",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 9
	},
	{ .name   = "L1I",
	  .desc   = "L1I instruction fetch",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x80,
	  .umasks = {
		{ .uname  = "CYCLES_STALLED",
		  .udesc  = "L1I instruction fetch stall cycles",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "HITS",
		  .udesc  = "L1I instruction fetch hits",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "MISSES",
		  .udesc  = "L1I instruction fetch misses",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "READS",
		  .udesc  = "L1I Instruction fetches",
		  .ucode  = 0x3,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name   = "L2_WRITE",
	  .desc   = "L2 demand lock/store RFO",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x27,
	  .umasks = {
		{ .uname  = "LOCK_E_STATE",
		  .udesc  = "L2 demand lock RFOs in E state",
		  .ucode  = 0x40,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOCK_HIT",
		  .udesc  = "All demand L2 lock RFOs that hit the cache",
		  .ucode  = 0xE0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOCK_I_STATE",
		  .udesc  = "L2 demand lock RFOs in I state (misses)",
		  .ucode  = 0x10,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOCK_M_STATE",
		  .udesc  = "L2 demand lock RFOs in M state",
		  .ucode  = 0x80,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOCK_MESI",
		  .udesc  = "All demand L2 lock RFOs",
		  .ucode  = 0xF0,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "LOCK_S_STATE",
		  .udesc  = "L2 demand lock RFOs in S state",
		  .ucode  = 0x20,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO_HIT",
		  .udesc  = "All L2 demand store RFOs that hit the cache",
		  .ucode  = 0xE,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO_I_STATE",
		  .udesc  = "L2 demand store RFOs in I state (misses)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO_M_STATE",
		  .udesc  = "L2 demand store RFOs in M state",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO_MESI",
		  .udesc  = "All L2 demand store RFOs",
		  .ucode  = 0xF,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "RFO_S_STATE",
		  .udesc  = "L2 demand store RFOs in S state",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 11
	},
	{ .name   = "SNOOP_RESPONSE",
	  .desc   = "Snoop",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xB8,
	  .umasks = {
		{ .uname  = "HIT",
		  .udesc  = "Thread responded HIT to snoop",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "HITE",
		  .udesc  = "Thread responded HITE to snoop",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "HITM",
		  .udesc  = "Thread responded HITM to snoop",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 3
	},
	{ .name   = "L1D",
	  .desc   = "L1D cache",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0x3,
	  .ngrp = 1,
	  .code = 0x51,
	  .umasks = {
		{ .uname  = "M_EVICT",
		  .udesc  = "L1D cache lines replaced in M state ",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "M_REPL",
		  .udesc  = "L1D cache lines allocated in the M state",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "M_SNOOP_EVICT",
		  .udesc  = "L1D snoop eviction of cache lines in M state",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "REPL",
		  .udesc  = "L1 data cache lines allocated",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 4
	},
	{ .name   = "RESOURCE_STALLS",
	  .desc   = "Resource related stall cycles",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xA2,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "Resource related stall cycles",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_DFL,
		},
		{ .uname  = "FPCW",
		  .udesc  = "FPU control word write stall cycles",
		  .ucode  = 0x20,
		  .uflags = 0,
		},
		{ .uname  = "LOAD",
		  .udesc  = "Load buffer stall cycles",
		  .ucode  = 0x2,
		  .uflags = 0,
		},
		{ .uname  = "MXCSR",
		  .udesc  = "MXCSR rename stall cycles",
		  .ucode  = 0x40,
		  .uflags = 0,
		},
		{ .uname  = "OTHER",
		  .udesc  = "Other Resource related stall cycles",
		  .ucode  = 0x80,
		  .uflags = 0,
		},
		{ .uname  = "ROB_FULL",
		  .udesc  = "ROB full stall cycles",
		  .ucode  = 0x10,
		  .uflags = 0,
		},
		{ .uname  = "RS_FULL",
		  .udesc  = "Reservation Station full stall cycles",
		  .ucode  = 0x4,
		  .uflags = 0,
		},
		{ .uname  = "STORE",
		  .udesc  = "Store buffer stall cycles",
		  .ucode  = 0x8,
		  .uflags = 0,
		},
	  },
	  .numasks = 8
	},
	{ .name   = "RAT_STALLS",
	  .desc   = "All RAT stall cycles",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0xD2,
	  .flags  = 0,
	  .umasks = {
		{ .uname  = "ANY",
		  .udesc  = "All RAT stall cycles",
		  .ucode  = 0xF,
		  .uflags = INTEL_X86_DFL|INTEL_X86_NCOMBO,
		},
		{ .uname  = "FLAGS",
		  .udesc  = "Flag stall cycles",
		  .ucode  = 0x1,
		  .uflags = 0,
		},
		{ .uname  = "REGISTERS",
		  .udesc  = "Partial register stall cycles",
		  .ucode  = 0x2,
		  .uflags = 0,
		},
		{ .uname  = "ROB_READ_PORT",
		  .udesc  = "ROB read port stalls cycles",
		  .ucode  = 0x4,
		  .uflags = 0,
		},
		{ .uname  = "SCOREBOARD",
		  .udesc  = "Scoreboard stall cycles",
		  .ucode  = 0x8,
		  .uflags = 0,
		},
	  },
	  .numasks = 5
	},
	{ .name   = "CPU_CLK_UNHALTED",
	  .desc   = "Cycles when processor is not in halted state",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x3C,
	  .umasks = {
		{ .uname  = "THREAD_P",
		  .udesc  = "Cycles when thread is not halted (programmable counter)",
		  .ucode  = 0x00,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "REF_P",
		  .udesc  = "Reference base clock (133 Mhz) cycles when thread is not halted",
		  .ucode  = 0x01,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 2
	},
	{ .name   = "L1D_WB_L2",
	  .desc   = "L1D writebacks to L2",
	  .modmsk = INTEL_V3_ATTRS,
	  .cntmsk = 0xf,
	  .ngrp = 1,
	  .code = 0x28,
	  .umasks = {
		{ .uname  = "E_STATE",
		  .udesc  = "L1 writebacks to L2 in E state",
		  .ucode  = 0x4,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "I_STATE",
		  .udesc  = "L1 writebacks to L2 in I state (misses)",
		  .ucode  = 0x1,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "M_STATE",
		  .udesc  = "L1 writebacks to L2 in M state",
		  .ucode  = 0x8,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "MESI",
		  .udesc  = "All L1 writebacks to L2",
		  .ucode  = 0xF,
		  .uflags = INTEL_X86_NCOMBO,
		},
		{ .uname  = "S_STATE",
		  .udesc  = "L1 writebacks to L2 in S state",
		  .ucode  = 0x2,
		  .uflags = INTEL_X86_NCOMBO,
		},
	  },
	  .numasks = 5
	},
	{.name = "MISPREDICTED_BRANCH_RETIRED",
	 .modmsk = INTEL_V3_ATTRS,
	 .cntmsk = 0xf,
	 .code= 0x00c5,
	 .desc =  "count mispredicted branch instructions at retirement. Specifically, this event counts at retirement of the last micro-op of a branch instruction in the architectural path of the execution and experienced misprediction in the branch prediction hardware",
	}
};
#define PME_WSM_EVENT_COUNT	  (sizeof(intel_wsm_pe)/sizeof(intel_x86_entry_t))
